import { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import { Question } from '@/types/curriculum';

interface WrittenCalcInputProps {
    question: Question;
    onComplete: (isCorrect: boolean) => void;
}

export interface WrittenCalcInputRef {
    handleInput: (val: string) => void;
}

const WrittenCalcInput = forwardRef<WrittenCalcInputRef, WrittenCalcInputProps>(({ question, onComplete }, ref) => {
    const metadata = question.metadata;
    const valA = metadata?.a || 0;
    const valB = metadata?.b || 0;

    // Convert to string for digit access
    const strA = valA.toString();
    const strB = valB.toString();

    // Calculate expected answer and dimensions
    const correctAnswer = metadata?.expectedAnswer !== undefined
        ? parseInt(metadata.expectedAnswer)
        : valA + valB;
    const strAnswer = correctAnswer.toString(); // e.g. "105"

    // Determine number of columns needed based on max length
    // e.g. 899 + 899 = 1798 (4 digits) -> 4 columns
    const numCols = Math.max(strA.length, strB.length, strAnswer.length);

    // State
    // digits: index 0 = ones, 1 = tens, 2 = hundreds...
    const [inputs, setInputs] = useState<string[]>([]);
    const [carryMarks, setCarryMarks] = useState<boolean[]>([]);
    // carryMarks[i] represents carry coming INTO column i? or carry FROM column i?
    // Let's stick to: carryMarks[i] is carry FROM column i (input to column i+1).
    // So for numCols=3 (0,1,2), we need carry from 0->1, 1->2. Indices 0 and 1.
    // Size should be numCols - 1 (or numCols for safety). Let's use numCols to be safe and use [col] index logic.
    // Actually, carryMarks[col] = true means "Carry marked above column col+1".
    // So carryMarks[0] -> displayed above col 1 (Tens).

    const [activeCol, setActiveCol] = useState<number | null>(0); // Start at ones (0)
    const [submitted, setSubmitted] = useState(false);
    const [isCorrect, setIsCorrect] = useState<boolean | null>(null);
    const [shake, setShake] = useState(false);

    // Reset when question changes
    useEffect(() => {
        setInputs(Array(numCols).fill(''));
        setCarryMarks(Array(numCols).fill(false));
        setActiveCol(0);
        setSubmitted(false);
        setIsCorrect(null);
    }, [question.id, numCols]);

    // Calculate needed carries for validation/focus logic
    // We need to know if a carry SHOULD be entered for specific column.
    // Logic: Calculate sum at each column including carry from previous.
    // If sum >= 10, then carry to next is required.

    const isCarryRequired = (colIndex: number) => {
        // Calculate carry generated by THIS column (to the next).
        // To do this accurately, we need to know the state of carry coming INTO this column.
        // But for "correct" mental model, we just calculate based on values.
        // Recursively? Or purely based on static numbers?
        // User might screw up input, but the carry requirement is based on the MATH.

        // We can simulate the addition digit by digit.
        let carry = 0;
        for (let i = 0; i <= colIndex; i++) {
            const dA = parseInt(getDigit(strA, i) || '0');
            const dB = parseInt(getDigit(strB, i) || '0');
            const sum = dA + dB + carry;
            if (i === colIndex) {
                return sum >= 10;
            }
            carry = Math.floor(sum / 10);
        }
        return false;
    };

    // Current focus logic
    // We prioritize carry input for the *next* column if the *current* activeCol generates a carry.
    // Wait, if activeCol is used for INPUT digit of column activeCol.
    // If column activeCol generates a carry, that carry is marked above column activeCol+1.
    // Usually user calculates column 0, realizes sum > 10, writes 1 above col 1, then writes result in col 0.
    // So if activeCol == 0, and it generates carry, we want user to mark carry above col 1.
    // That mark is `carryMarks[0]` (using my convention "carry from 0").

    // So isFocusingCarry should be true if:
    // We are at activeCol.
    // activeCol generates a carry (isCarryRequired(activeCol)).
    // And that carry mark (carryMarks[activeCol]) is NOT yet set.

    const currentGeneratedCarry = activeCol !== null ? isCarryRequired(activeCol) : false;
    const isFocusingCarry =
        !submitted &&
        activeCol !== null &&
        activeCol < numCols - 1 && // Cannot carry beyond max columns (unless result expands, but numCols covers result)
        currentGeneratedCarry &&
        !carryMarks[activeCol];

    const handleInput = (val: string) => {
        if (submitted || activeCol === null) return;

        if (val === 'DEL') {
            // Allow delete even if focusing carry, to correct previous input

            if (inputs[activeCol]) {
                const newInputs = [...inputs];
                newInputs[activeCol] = '';
                setInputs(newInputs);
            } else if (activeCol > 0) {
                // Return to previous column
                setActiveCol(activeCol - 1);
            }
            return;
        }

        if (val === 'ENTER') {
            checkAnswer();
            return;
        }

        if (val >= '0' && val <= '9') {
            // Priority: Carry Mark Input
            if (isFocusingCarry) {
                if (val === '1') {
                    // Correct carry input
                    const newCarryMarks = [...carryMarks];
                    newCarryMarks[activeCol] = true; // Mark carry from activeCol (displays above activeCol+1)
                    setCarryMarks(newCarryMarks);
                } else {
                    // Incorrect carry input
                    setShake(true);
                    setTimeout(() => setShake(false), 300);
                }
                return;
            }

            const newInputs = [...inputs];
            newInputs[activeCol] = val;
            setInputs(newInputs);

            // Auto-advance logic
            // If there's more columns to fill (based on numCols), advance.
            if (activeCol < numCols - 1) {
                setActiveCol(activeCol + 1);
            } else {
                setTimeout(() => checkAnswer(newInputs), 300);
            }
        }
    };

    useImperativeHandle(ref, () => ({
        handleInput
    }));

    const toggleCarryMark = (carryFromColIdx: number) => {
        if (submitted) return;

        // Toggle logic
        const newMarks = [...carryMarks];
        newMarks[carryFromColIdx] = !newMarks[carryFromColIdx];
        setCarryMarks(newMarks);

        // If turning ON a needed carry at current column, check if we should auto-advance?
        // Actually, logic is handled by handleInput '1'. 
        // This toggle is for clicking UI.
        // If user clicks, handle same as '1' input if it matches active need?

        // If we are stuck at isFocusingCarry, and user clicks valid mark, we unblock.
        // No extra logic needed because isFocusingCarry checks state.
    };

    const checkAnswer = (currentInputs = inputs) => {
        // Assume empty strings are 0? Or require full input?
        // Usually require full inputs up to significant digits.
        // But let's just parse.
        if (currentInputs.every(c => c === '')) return;

        // inputs: [ones, tens, hundreds...]
        // Reverse to get string: "hundredsTensOnes"
        const inputValStr = [...currentInputs].reverse().join('');
        const inputVal = parseInt(inputValStr);

        const isCorrectVal = inputVal === correctAnswer;

        setSubmitted(true);
        setIsCorrect(isCorrectVal);
        setActiveCol(null);

        if (!isCorrectVal) {
            setShake(true);
            setTimeout(() => setShake(false), 500);
            const audio = new Audio('/sounds/wrong.mp3');
            audio.play().catch(() => { });
        } else {
            const audio = new Audio('/sounds/correct.mp3');
            audio.play().catch(() => { });
        }

        setTimeout(() => {
            onComplete(isCorrectVal);
        }, isCorrectVal ? 500 : 1500);
    };

    // Helper to get digit
    function getDigit(str: string, power: number) {
        if (power >= str.length) return '';
        return str[str.length - 1 - power];
    }

    // Render columns: We will render from Left (Highest Power) to Right (0).
    // numCols = 4 -> powers 3, 2, 1, 0.
    const columns = [];
    for (let i = numCols - 1; i >= 0; i--) {
        columns.push(i);
    }

    return (
        <div className="flex flex-col items-center w-full max-w-[320px] mx-auto px-2 select-none">
            {/* Instruction */}
            <div className="mb-2 text-slate-500 font-bold text-center min-h-[1.5rem] text-sm">
                {isFocusingCarry && "くり上がりを入力しよう (1)"}
                {!isFocusingCarry && !submitted && activeCol !== null && `${Math.pow(10, activeCol)}の位を計算しよう`}
                {submitted && isCorrect && "正解！"}
                {submitted && !isCorrect && "ちがうみたい..."}
            </div>

            {/* Calculation Grid */}
            <div className={`
                flex flex-col items-center text-5xl font-black font-mono leading-none tracking-widest relative
                transition-transform duration-100 ${shake ? 'translate-x-[4px]' : ''} ${shake ? 'translate-x-[-4px]' : ''}
            `}>
                {/* Dynamic Grid Layout */}
                <div className="flex justify-center w-auto">
                    {/* Iterate Columns Descending Power */}
                    {columns.map((power) => {
                        // Mark above this column comes from "power-1".
                        // Wait. carryMarks[i] is carry FROM i TO i+1.
                        // So carry mark ABOVE column 'power' is carryMarks[power-1].
                        // Exception: power=0 has no carry above it from -1.

                        const carryFrom = power - 1;
                        const hasCarryMark = carryFrom >= 0;

                        return (
                            <div key={power} className="flex flex-col w-14 items-center relative">
                                {/* Carry Mark Bubble */}
                                <div className="h-8 w-full flex items-end justify-center mb-1">
                                    {hasCarryMark ? (
                                        <div
                                            className={`
                                                w-6 h-6 rounded-full flex items-center justify-center text-xs border-2 cursor-pointer transition-colors
                                                ${carryMarks[carryFrom] ? 'bg-blue-100 border-blue-400 text-blue-600 font-bold' : 'border-slate-200 text-transparent hover:border-slate-300'}
                                                ${isFocusingCarry && activeCol === carryFrom ? 'ring-4 ring-orange-400 bg-orange-100 border-orange-400 animate-pulse' : ''}
                                            `}
                                            onClick={() => toggleCarryMark(carryFrom)}
                                        >
                                            1
                                        </div>
                                    ) : (
                                        <div className="w-6 h-6"></div>
                                    )}
                                </div>

                                {/* Top Number (A) */}
                                <div className="h-12 w-full flex items-center justify-center text-slate-700 z-10">
                                    {getDigit(strA, power)}
                                </div>

                                {/* Bottom Number (B) */}
                                <div className="h-12 w-full flex items-center justify-center text-slate-700 z-10 relative">
                                    {/* Operator if last column (highest power) or specific column? 
                                        Standard written calc puts operator far left. 
                                        Here we can just place it absolute relative to the grid wrapper? 
                                        Or attachment to the leftmost column? 
                                    */}
                                    {power === numCols - 1 && (
                                        <span className="absolute left-[-1.5rem] bottom-2 text-3xl text-slate-400 font-normal">
                                            {metadata?.operator || '+'}
                                        </span>
                                    )}
                                    {getDigit(strB, power)}
                                </div>

                                {/* Line across just this column? No, standard is full line. 
                                    We can do border-bottom on the container or individual. 
                                    Individual border-b works if they connect.
                                */}
                                <div className="w-full border-b-4 border-slate-800 z-10 absolute bottom-[3.5rem] pointer-events-none"></div>

                                {/* Answer Input */}
                                <div className="h-14 w-full flex items-center justify-center pt-2 z-10">
                                    <div className={`
                                        w-12 h-12 flex items-center justify-center rounded border-2 text-4xl
                                        ${activeCol === power && !submitted
                                            ? (isFocusingCarry ? 'border-slate-300 bg-slate-50 opacity-50' : 'border-blue-500 bg-blue-50 ring-2 ring-blue-200')
                                            : 'border-slate-200 bg-slate-50 text-slate-800'}
                                        ${submitted && !isCorrect ? 'bg-red-50 border-red-200' : ''}
                                        ${submitted && isCorrect ? 'bg-green-50 border-green-200' : ''}
                                    `}>
                                        {inputs[power]}
                                    </div>
                                </div>

                            </div>
                        );
                    })}
                </div>

                {/* Grid Vertical Lines (Background) */}
                <div className="absolute inset-0 flex justify-center pointer-events-none opacity-5 z-0 mt-8 mb-14">
                    {columns.map(c => (
                        <div key={c} className="w-14 border-r-2 border-slate-900 bg-slate-50 last:border-r-0"></div>
                    ))}
                </div>

            </div>
        </div>
    );
});

export default WrittenCalcInput;
